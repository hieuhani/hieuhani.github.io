<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Building your BFF with GraphQL</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/288e6fce7d19ad979b67.css" as="style"/><link rel="stylesheet" href="/_next/static/css/288e6fce7d19ad979b67.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd7d7fff9e98be66a830.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd7d7fff9e98be66a830.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-af8d060cb140570bcfb2.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-92300432a1172ef1338b.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-899697ea82bdc85e7a94.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-5f22d077be68381df9e9.js" as="script"/><link rel="preload" href="/_next/static/chunks/571-41b2c65dc001313f5918.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bslug%5D-ba501843032cf0ceb4ed.js" as="script"/></head><body><div id="__next"><div><nav class="container py-4 flex items-center justify-between lg:justify-start mb-2" aria-label="Global"><div class="flex items-center flex-grow flex-shrink-0 lg:flex-grow-0"><div class="flex items-center justify-between w-full md:w-auto"><a class="index-link active" href="/"><div class="flex items-center"><div><h2 class="text-2xl">Hieu Tran</h2><blockquote>Product oriented developer</blockquote></div></div></a></div></div><nav id="navigation" class="fixed inset-0 bg-white z-10 flex items-center justify-center	 hidden"><div class="flex flex-col nav-items styles_nav-items__1aEZC"><a class="font-medium text-gray-500 hover:text-gray-900 px-4 index-link active" href="/">Home</a><a class="font-medium text-gray-500 hover:text-gray-900 px-4" href="/portfolio">Portfolio</a><a class="font-medium text-gray-500 hover:text-gray-900 px-4" href="/resume">Resume</a></div></nav></nav></div><div><header><div class="mb-12 text-center"><dl><div><dt class="sr-only">Published on</dt><dd class="text-base leading-6 font-medium text-gray-500"><time dateTime="2020-10-15T06:25:07.322Z">October 15, 2020</time></dd></div></dl><div><h2 class="text-2xl leading-9 font-medium text-gray-700 tracking-tight sm:text-3xl sm:leading-10 md:text-5xl md:leading-14">Building your BFF with GraphQL</h2></div></div></header><article class="max-w-2xl mx-auto"><div><div class="mb-8 md:mb-8 sm:mx-0"><img src="/images/jason-rosewell-ASKeuOZqhYU.jpg" alt="Building your BFF with GraphQL&#x27;s cover" class="shadow-small hover:shadow-medium transition-shadow duration-200"/></div><div class="styles_markdown__3B93I"><p>As a front-end developer, I love to focus on UI/UX and what the users see is a single monolithic product and they might not want to know about underlying APIs. Back-end developers often want to decouple the API layer. To achieve the dual goal, we can rely on GraphQL to build up a backend for the front end as an extra layer to consolidate and aggregate data from these API services and delivery to the front end side as a single endpoint.</p>
<p>Following the definition of BFF by Sam Newman and associates, the BFF is tightly coupled to a specific user experience and needs to aggregate multiple downstream calls to deliver user functionalities. Not to say nothing of we often have various clients such as web browser, mobile browser, iOS/Android application.</p>
<h2>Why GraphQL?</h2>
<p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</p>
<h3>Query for what you need</h3>
<p>Each client has different perspectives about data shape, for example: getting user details (basic information, addresses, contacts…), the mobile version might have options to click to navigate to view the list of addresses or contacts, but in the web version with larger display area, it might display everything.</p>
<h3>Multiple queries at once request</h3>
<p>Sometimes we need to make multiple API calls and will choose to fetch the data sequentially or parallelly, more logic and round trips added. With GraphQL you can make many requests at once.</p>
<h3>Static type generation</h3>
<p>We can not avoid the benefit of static type when developing the application, that's why TypeScript has been increasing in its popularity for the last couple of years. Some tools offer TypeScript definition code generation from the GraphQL queries <a href="https://www.graphql-code-generator.com/" title="GraphQL Code Generator">GraphQL Code Generator</a> or <a href="https://github.com/apollographql/apollo-tooling" title="Apollo Codegen">Apollo Codegen</a>.</p>
<h3>Single source of truth for clients</h3>
<p>We can choose to define all GraphQL schema before developing, the backend side could rely on the schema definition to develop, and the front end side can trust the data shape. Later when something needs to be changed from the other services, we have a less painful choice to patch the update.</p>
<h3>Rapid prototype development</h3>
<p>GraphQL has a single endpoint and the client can decide which data to get. We can think it's like using raw queries to access the server database.</p>
<h3>Self-documented</h3>
<p>To build up a GraphQL service, we need to create the schema for everything from model definition to resolvers. As the schema is tightly coupled with the development code we will naturally update the docs.</p>
<h2>GraphQL drawbacks</h2>
<p>Since GraphQL has only one endpoint, it's nearly impossible to rely on HTTP cache control as well as route-based authorization rules.</p>
<p>Almost all people can point out that using a single endpoint will lead to a bottleneck and we have to spend time to scale and maintain the availability for that. Luckily we can learn from <a href="https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2" title="how Netflix scales its API with GraphQL federation">how Netflix scales its API with GraphQL federation</a>.</p>
<p>When applying GraphQL, people tend to migrate all other Restful APIs to GraphQL because using both of them feels weird for the perfectionist. Consequently, it always takes an extra workload for the development process.</p>
<p>When using GraphQL especially Apollo GraphQL, the client-side often comes with Apollo Client and it makes your client setup is more cumbersome.</p>
<p>A well-known problem when people explore GraphQL is N+1 queries, it's the same as the ORM problem. Of course, we might hear about DataLoader as a data fetching layer to reduce requests by batching and caching but to me, I'd prefer to do an eager query.</p>
</div></div></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Building your BFF with GraphQL","excerpt":"Following the microservice architecture, we often have multiple API services and the developers need to ad-hoc integrate with them. This post is about using GraphQL to create a backend for front end as a unified aggregation layer at the edge.","coverImage":"/images/jason-rosewell-ASKeuOZqhYU.jpg","date":"2020-10-15T06:25:07.322Z","content":"\u003cp\u003eAs a front-end developer, I love to focus on UI/UX and what the users see is a single monolithic product and they might not want to know about underlying APIs. Back-end developers often want to decouple the API layer. To achieve the dual goal, we can rely on GraphQL to build up a backend for the front end as an extra layer to consolidate and aggregate data from these API services and delivery to the front end side as a single endpoint.\u003c/p\u003e\n\u003cp\u003eFollowing the definition of BFF by Sam Newman and associates, the BFF is tightly coupled to a specific user experience and needs to aggregate multiple downstream calls to deliver user functionalities. Not to say nothing of we often have various clients such as web browser, mobile browser, iOS/Android application.\u003c/p\u003e\n\u003ch2\u003eWhy GraphQL?\u003c/h2\u003e\n\u003cp\u003eGraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.\u003c/p\u003e\n\u003ch3\u003eQuery for what you need\u003c/h3\u003e\n\u003cp\u003eEach client has different perspectives about data shape, for example: getting user details (basic information, addresses, contacts…), the mobile version might have options to click to navigate to view the list of addresses or contacts, but in the web version with larger display area, it might display everything.\u003c/p\u003e\n\u003ch3\u003eMultiple queries at once request\u003c/h3\u003e\n\u003cp\u003eSometimes we need to make multiple API calls and will choose to fetch the data sequentially or parallelly, more logic and round trips added. With GraphQL you can make many requests at once.\u003c/p\u003e\n\u003ch3\u003eStatic type generation\u003c/h3\u003e\n\u003cp\u003eWe can not avoid the benefit of static type when developing the application, that's why TypeScript has been increasing in its popularity for the last couple of years. Some tools offer TypeScript definition code generation from the GraphQL queries \u003ca href=\"https://www.graphql-code-generator.com/\" title=\"GraphQL Code Generator\"\u003eGraphQL Code Generator\u003c/a\u003e or \u003ca href=\"https://github.com/apollographql/apollo-tooling\" title=\"Apollo Codegen\"\u003eApollo Codegen\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eSingle source of truth for clients\u003c/h3\u003e\n\u003cp\u003eWe can choose to define all GraphQL schema before developing, the backend side could rely on the schema definition to develop, and the front end side can trust the data shape. Later when something needs to be changed from the other services, we have a less painful choice to patch the update.\u003c/p\u003e\n\u003ch3\u003eRapid prototype development\u003c/h3\u003e\n\u003cp\u003eGraphQL has a single endpoint and the client can decide which data to get. We can think it's like using raw queries to access the server database.\u003c/p\u003e\n\u003ch3\u003eSelf-documented\u003c/h3\u003e\n\u003cp\u003eTo build up a GraphQL service, we need to create the schema for everything from model definition to resolvers. As the schema is tightly coupled with the development code we will naturally update the docs.\u003c/p\u003e\n\u003ch2\u003eGraphQL drawbacks\u003c/h2\u003e\n\u003cp\u003eSince GraphQL has only one endpoint, it's nearly impossible to rely on HTTP cache control as well as route-based authorization rules.\u003c/p\u003e\n\u003cp\u003eAlmost all people can point out that using a single endpoint will lead to a bottleneck and we have to spend time to scale and maintain the availability for that. Luckily we can learn from \u003ca href=\"https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2\" title=\"how Netflix scales its API with GraphQL federation\"\u003ehow Netflix scales its API with GraphQL federation\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWhen applying GraphQL, people tend to migrate all other Restful APIs to GraphQL because using both of them feels weird for the perfectionist. Consequently, it always takes an extra workload for the development process.\u003c/p\u003e\n\u003cp\u003eWhen using GraphQL especially Apollo GraphQL, the client-side often comes with Apollo Client and it makes your client setup is more cumbersome.\u003c/p\u003e\n\u003cp\u003eA well-known problem when people explore GraphQL is N+1 queries, it's the same as the ORM problem. Of course, we might hear about DataLoader as a data fetching layer to reduce requests by batching and caching but to me, I'd prefer to do an eager query.\u003c/p\u003e\n","slug":"building-your-bff-with-graphql"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"building-your-bff-with-graphql"},"buildId":"c04NSBCZX34a7lXMdRa-j","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-eef578260fd80f8fff94.js"></script><script src="/_next/static/chunks/webpack-af8d060cb140570bcfb2.js" async=""></script><script src="/_next/static/chunks/framework-92300432a1172ef1338b.js" async=""></script><script src="/_next/static/chunks/main-899697ea82bdc85e7a94.js" async=""></script><script src="/_next/static/chunks/pages/_app-5f22d077be68381df9e9.js" async=""></script><script src="/_next/static/chunks/571-41b2c65dc001313f5918.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-ba501843032cf0ceb4ed.js" async=""></script><script src="/_next/static/c04NSBCZX34a7lXMdRa-j/_buildManifest.js" async=""></script><script src="/_next/static/c04NSBCZX34a7lXMdRa-j/_ssgManifest.js" async=""></script></body></html>