{"pageProps":{"paginatedPost":{"posts":[{"title":"Xây dựng multi-tenant websites với NuxtJS","excerpt":"Multi-tenant websites cho phép chúng ta chạy nhiều websites trên cùng một server instance với nhiều lợi ích giúp tiết kiệm tài nguyên server và chi phí cũng như thời gian phát triển. Hôm nay mình sẽ chia sẻ về cách mình xây dựng hệ thống nhiều websites này.","coverImage":"/images/george-becker-129494.jpg","date":"2021-02-21T08:35:07.322Z","content":"\nVề bối cách thực tế trong thời Covid, bán hàng online nở rộ, cửa hàng bánh mình đang làm thêm cũng gặp nhiều khó khăn trong bán hàng, mình nảy ra ý định xây trang web để bán bánh online giúp cửa hàng có thêm doanh thu. Khi về gặp đứa bạn chuyên bán hàng online để tìm hiểu nhu cầu thực tế và cách triển khai thì cũng được biết là bạn mình cũng muốn có trang web riêng để có thêm kênh bán hàng, và mình cũng gạ để mình làm cho luôn.\n\nĐầu tiên mọi người đều sẽ hỏi sao không dùng mấy dịch vụ SaaS có sẵn như Shopify, Sapo… hay cài đặt Wordpress, Magento… nhỉ? Thật ra là một developer thì luôn luôn có suy nghĩ tự làm tự code từ đầu, chưa có sự thực dụng và nhạy bén trong kinh doanh và mình cũng tự tin là có thể làm ra những sản phẩm có nền tảng công nghệ tốt nhất nên là về mặt tinh thần là làm thôi, làm còn để học thêm nữa. Và ngoài ra thì với việc sử dụng SaaS mình cũng không có toàn quyền tuỳ chỉnh, dữ liệu thì cũng bị phụ thuộc, sử dụng mã nguồn mở thì đôi khi nó có quá nhiều thứ mình không hoặc chưa cần đến. Với những sản phẩm mã nguồn mở phổ biến kể trên như Wordpress hay Magento thì mình cũng đã đều dùng thử, công nhận là hệ thống plugins dày đặc cũng hỗ trợ mọi thứ từ A-Z sẽ là một giải pháp hoàn hảo nếu mình thuần phát triển kinh doanh. Đặc điểm của những mã nguồn kể trên phần giao diện vẫn là thuần server render một khối, những tính năng tương tác thường sẽ phát triển theo hệ jQuery. Mình thì mong muốn sử dụng những framework, library hiện đại như React hay Vue để xây dựng hơn.\n\nỞ bài này mình sẽ tập trung vào phần phát triển front end, và làm sao để hỗ trợ chạy nhiều trang web trên cùng một server instance theo dạng multi-tenant để mình có thể dễ dàng làm thêm nhiều trang web nhanh chóng dễ dàng, mà vẫn đảm bảo sự tùy biến cần thiết, vì rất có thể ngoài những trang bán hàng kể trên mình sẽ làm thêm những trang tin tức, blog, landing page cho mình hoặc cho người thân thậm chí cho cả người ngoài với chi phí tiết kiệm.\n\nVới đề bài ban đầu đặt ra là làm một trang web bán hàng, thì mình nghĩ ngay đến những yêu cầu công nghệ như sau:\n\n- Server side rendering (mình muốn có trải nghiệm tốt và hỗ trợ SEO).\n- Có dashboard cho việc quản lý bán hàng, SPA thôi là đủ.\n- Để có trải nghiệm tốt thì mình sẽ làm cả bản mobile và desktop riêng, giao diện responsive chỉ để gọi là tránh vỡ.\n- Chia sẻ được UI component nhiều nhất có thể.\n- PWA\n\nCó 2 ứng cử viên cho framework sử dụng đó là NextJS và NuxtJS cũng là đại diện cho React và Vue. Mình đã từng sử dụng cả 2 frameworks này rồi thì có mấy cân nhắc như sau:\n\n- Đối với NextJS, gần đây nó có rất nhiều thay đổi và cải thiện tích cực về performance cũng như trải nghiệm dev, từ cơ chế SSG, tối ưu hình ảnh, React hỗ trợ Typescript tốt… nói chung là hoàn hảo để xây trang ecommerce.\n- NuxtJS thì cũng là 1 framework yêu thích của mình với khả năng tuỳ biến cao qua những file configs, modules đa dạng. Nhưng có điều hiện giờ vẫn chưa chính thức hỗ trợ Vue 3 mới nhất. Cảm giác của mình là lo sợ khi làm xong thì nó lại nâng version mới.\n\nBan đầu mình cũng khá nghiêng về sử dụng NextJS và cũng thử init project, tuỳ biến để có thể hỗ trợ multi-tenant theo từng subfolders trong folder pages/. Đối với NextJS, có 2 phần việc chính phải làm là custom NextJS server để map lại những routes theo tenant, phần này khá dễ. Sửa đến đây khi chạy server lên sẽ không thấy gì, mở developer tools ra thì sẽ thấy hiện lỗi 404 khi NextJS cần load những thông tin props, manifest, khi này mình có view source lên thì thấy hiện đúng nội dung, chứng tỏ việc server side rendering diễn ra bình thường, vậy là vấn để xảy ra trong quá trình client side rehydration, để sửa cho phần này mình cần map lại những chỗ NextJS lấy thông tin props, manifest để hiển thị, mình cũng có Google thì cơ bản là NextJS không sinh ra cho việc này, rồi gạ dùng Vercel Mutli Zones. Chỉ còn cách sửa vào core của NextJS rồi, mò mấy hôm thì cũng sửa được nhưng việc sửa vào core khá mệt, do mình cần beautify rồi mò từng chỗ, việc folk lại cũng mệt không kém bởi vì NextJS đang trong giai đoạn active development. (Hiện giờ khi viết bài này thì mình biết là có cách khách để mokey-patching runtime)\n\nVà cuối cùng mình đã quyết định dùng NuxtJS, bản thân hệ thống route của NuxtJS dựa trên Vue Router nên việc cài đặt cũng không quá khó, ngoài ra còn có thể dễ dàng viết thêm plugins mà không cần sửa core. Ý tưởng của mình cũng là sẽ tạo các folder tương ứng với các tenant nằm trong folder pages/ của Nuxt, rồi từ domain sẽ quyết định load folder nào trong folder pages. Cách thực hiện khá đơn giản, chỉ cần từ domain sẽ build lại route configs ứng theo từng tenant. Mình có làm 1 cái [module đơn giản ở đây](https://github.com/hieuhani/nuxt-multi-tenancy-module 'module đơn giản ở đây') cho việc này.\nTiếp theo đặt tenant trong folder pages nghe cũng không xịn, (NuxtJS sử dụng file-based routes) vậy nên mình muốn đổi tên thành folder sites. Thật may mắn vì NuxtJS cho đổi tên folder pages một cách dễ dàng qua [Nuxt config](https://nuxtjs.org/docs/2.x/directory-structure/nuxt-config/#dir 'Nuxt config').\n\nĐối với Nuxt mình cũng có thể linh hoạt quyết định trang nào SSR trang nào CSR một cách đơn giản dễ dàng thông qua Nuxt config hoặc Nuxt middleware, hoặc đặt trong component client-only.\n\nSau khi đã hoàn thành việc hỗ trợ multi-tenant qua việc map tên miền với tệp các routes tương ứng trong folder sites thì mình đã tự tin hơn cho ý tưởng này.\n\nTiếp theo trong quá trình làm thì mình nhận thấy giữa các trang web có rất nhiều điểm giống nhau, khác nhau có lẽ là đôi chút màu sắc, typography, vì vậy lại nghĩ đến giải pháp dài hơi hơn là cấu trúc để làm sao sử dụng lại được nhiều nhất, nghĩ ngay đến làm theme và xây bộ UI components.\n","slug":"xay-dung-multi-tenant-websites-voi-nuxtjs"},{"title":"Building your BFF with GraphQL","excerpt":"Following the microservice architecture, we often have multiple API services and the developers need to ad-hoc integrate with them. This post is about using GraphQL to create a backend for front end as a unified aggregation layer at the edge.","coverImage":"/images/jason-rosewell-ASKeuOZqhYU.jpg","date":"2020-10-15T06:25:07.322Z","content":"\nAs a front-end developer, I love to focus on UI/UX and what the users see is a single monolithic product and they might not want to know about underlying APIs. Back-end developers often want to decouple the API layer. To achieve the dual goal, we can rely on GraphQL to build up a backend for the front end as an extra layer to consolidate and aggregate data from these API services and delivery to the front end side as a single endpoint.\n\nFollowing the definition of BFF by Sam Newman and associates, the BFF is tightly coupled to a specific user experience and needs to aggregate multiple downstream calls to deliver user functionalities. Not to say nothing of we often have various clients such as web browser, mobile browser, iOS/Android application.\n\n## Why GraphQL?\n\nGraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.\n\n### Query for what you need\n\nEach client has different perspectives about data shape, for example: getting user details (basic information, addresses, contacts…), the mobile version might have options to click to navigate to view the list of addresses or contacts, but in the web version with larger display area, it might display everything.\n\n### Multiple queries at once request\n\nSometimes we need to make multiple API calls and will choose to fetch the data sequentially or parallelly, more logic and round trips added. With GraphQL you can make many requests at once.\n\n### Static type generation\n\nWe can not avoid the benefit of static type when developing the application, that's why TypeScript has been increasing in its popularity for the last couple of years. Some tools offer TypeScript definition code generation from the GraphQL queries [GraphQL Code Generator](https://www.graphql-code-generator.com/ 'GraphQL Code Generator') or [Apollo Codegen](https://github.com/apollographql/apollo-tooling 'Apollo Codegen').\n\n### Single source of truth for clients\n\nWe can choose to define all GraphQL schema before developing, the backend side could rely on the schema definition to develop, and the front end side can trust the data shape. Later when something needs to be changed from the other services, we have a less painful choice to patch the update.\n\n### Rapid prototype development\n\nGraphQL has a single endpoint and the client can decide which data to get. We can think it's like using raw queries to access the server database.\n\n### Self-documented\n\nTo build up a GraphQL service, we need to create the schema for everything from model definition to resolvers. As the schema is tightly coupled with the development code we will naturally update the docs.\n\n## GraphQL drawbacks\n\nSince GraphQL has only one endpoint, it's nearly impossible to rely on HTTP cache control as well as route-based authorization rules.\n\nAlmost all people can point out that using a single endpoint will lead to a bottleneck and we have to spend time to scale and maintain the availability for that. Luckily we can learn from [how Netflix scales its API with GraphQL federation](https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2 'how Netflix scales its API with GraphQL federation').\n\nWhen applying GraphQL, people tend to migrate all other Restful APIs to GraphQL because using both of them feels weird for the perfectionist. Consequently, it always takes an extra workload for the development process.\n\nWhen using GraphQL especially Apollo GraphQL, the client-side often comes with Apollo Client and it makes your client setup is more cumbersome.\n\nA well-known problem when people explore GraphQL is N+1 queries, it's the same as the ORM problem. Of course, we might hear about DataLoader as a data fetching layer to reduce requests by batching and caching but to me, I'd prefer to do an eager query.\n","slug":"building-your-bff-with-graphql"},{"title":"Client-to-microservice communication strategy in a nutshell","excerpt":"In recent years, microservice architecture has been becoming popular and being widely adopted by many various companies. The outcome often comes with several API services. In most cases, the client-side should be the one to aggregate data from different API services to deliver a seamless experience to the end-user.","coverImage":"/images/jason-rosewell-ASKeuOZqhYU.jpg","date":"2020-09-12T05:35:07.322Z","content":"\nIn recent years, microservice architecture has been becoming popular and being widely adopted by many various companies. The outcome often comes with several API services. In most cases, the client-side should be the one to aggregate data from different API services to deliver a seamless experience to the end-user.\n\nBefore digging in, I would scope the terms using in this post:\n\n- Client — A client may be a SPA website, a server sider rending website, a mobile application, an IoT device, or other integration services… but we will focus on web and mobile applications.\n- Web service APIs — There are SOAP, RPC (JSON-RPC, XML RPC, gRPC), REST.\n- Realtime APIs techniques — There are HTTP Long polling, Websocket, WebRTC, MQTT…\n- Web rendering techniques — Client-side rendering (initialize with HTML and CSS then the content comes from Javascript), Server-side rendering (server responses an HTML string), Universal rendering (combine the best of both client-side rendering and server-side rendering)\n\nChoosing the technique to integrate clients and servers to use depends on the context of the application and these use cases. As a front end developer, we usually concern about:\n\n- Service API endpoint: This will be the first question then are there multiple API endpoints or a single API endpoint?\n- Authentication: Cookies or JWT Bearer token?\n- Protocol: REST, RPC or do we need to support realtime with WebSocket or Long Polling?\n- Response data: What is the data interchange format is using? JSON or XML, gRPC? What about metadata conversion? Is the key field in the camel or snake case? What about data normalization?\n- Data synchronization: How we consolidate data from the server with client data?\n- Cooking data: when dealing with multiple data sources, we will need to compute derived data, but should that task is in server or client?\n\nIn a microservice architecture, the communication between services is also the most important factor, and they may use different effective protocols, data formats and that maybe not friendly with web front end developer (gRPC for example) but to support the client, they might need to expose extra HTTP Restful endpoint. Each microservice exposes a set of fine-grained endpoints and this can impact client-to-microservice communication.\n\nTo easier catch up the problem, let’s imagine that we are developing a shopping application (I would get the example from [this blog post](https://www.nginx.com/blog/building-microservices-using-an-api-gateway/#product-details-scenario 'this blog post')) and it’s likely that you need to implement a product details page.\n\n[![Amazon’s Android mobile application.](https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-1_amazon-apps.png)](https://cdn.wp.nginx.com/wp-content/uploads/2016/04/Richardson-microservices-part2-1_amazon-apps.png 'Amazon’s Android mobile application.')\n\nThis page does not only show the basic information such as name, description, price, but it may also show:\n\n- Shopping cart items\n- Order history\n- Customer reviews\n- Inventory status\n- Shipping options\n- Promotion information\n- Product recommendation\n- …\n\nTo have data to display this page in the microservice, the client has to communicate with:\n\n- Shopping cart service — to get the information about a user cart, it is not all about the cart items, it may need just a number of items in the cart\n- Order service — to display the brief of order information, it may need just the last order time\n- Inventory service — to display the inventory status, but it also needs just the number of remaining items or it may ask the policy service to display the buying tag, such as: Out of stock or Contact or Available in different locations…\n- Shipping service — to display the information about the shipping option, it is also not everything in the shipping entity response.\n- Realtime promotion service — when you see the customer stays in this product too long and you want to encourage her to buy, a promotion may be distributed…\n- …\n\nI guess you may think in mind: Oh, just a simple page consumes data from so many data sources (API services) or the number of items in the cart is just a number, does it necessary to get the whole cart data? Will the cart service expose an endpoint just for returning the number of items in the cart? When we want to personalize data by some factors like a user gender, location, or age range…it is so messed up.\n\nNow, it is enough background to get in, let’s look at 2 popular options.\n\n## Direct client-to-microservice communication\n\nA client app can make requests directly to some of the microservices.\n\n[![Using a direct client-to-microservice communication architecture](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/direct-client-to-microservice-communication.png)](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/direct-client-to-microservice-communication.png 'Using a direct client-to-microservice communication architecture')\n\nThis communication architecture could be good enough for a small microservice-based application. However, when you build large and complex applications as the example above, that approach faces a few issues.\n\nConsider the following questions/issues when developing a large application based on microservices:\n\n- How can client apps minimize the number of network requests to the backend and reduce chatty communication to multiple services?\n- What do we do when we need data from multiple dependant services?\n- How can client apps communicate with services that use non-Internet-friendly protocol?\n- The front end developers need to know multiple areas of the application are decomposed in microservices.\n- Too many round trips can result in multiple network round trips between the client and the server, adding significant latency.\n- Security issues also need to be a concern because all the microservices must be exposed to the ‘external world’, making the attack surface larger.\n\n## API Gateway\n\n### Single API Gateway\n\nThis is a service that provides a single-entry point for certain groups of microservices. It’s similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object-oriented design, but in this case, it’s part of a distributed system.\n\nTherefore, the API gateway sits between the client and the microservices, it plays as a reverse proxy, routing requests to services and can also provide additional cross-cutting features such as authentication and cache.\n\n[![Using a custom API Gateway service](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/direct-client-to-microservice-communication-versus-the-api-gateway-pattern/custom-service-api-gateway.png)](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/direct-client-to-microservice-communication-versus-the-api-gateway-pattern/custom-service-api-gateway.png 'Using a custom API Gateway service')\n\nThis API gateway will be growing and maybe bloated and could be similar to a monolithic service.\n\n### Multiple API Gateways\n\nAPI Gateways should be segregated based on business boundaries. Or we can choose to develop a different API Gateway for different clients (mobile or web). In this case, we have a pattern “Backend for Frontend” ([BFF](https://samnewman.io/patterns/architectural/bff/)) where each API Gateway can provide a different API tailored for each client.\n\n[![Using multiple custom API Gateways](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/direct-client-to-microservice-communication-versus-the-api-gateway-pattern/multiple-custom-api-gateways.png)](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/media/direct-client-to-microservice-communication-versus-the-api-gateway-pattern/multiple-custom-api-gateways.png 'Using multiple custom API Gateways')\n\nAt Netflix, they have also adopted this pattern: the Backend for Frontend pattern per client (Android, iOS, TV, Web).\n\n### API Gateway drawbacks\n\n- Creating an additional possible single point of failure\n- If not scaled out properly, the API gateway can become a bottleneck\n- Requiring additional development cost and future maintenance\n- It will slow down the team development if we do not prepare the adoption plan carefully\n\nEverything comes with pros and cons, especially choosing things not as simple as comparing the number of pros and cons, following the trend, or seeing others do that. To me, I tend to follow the core principle or the concept of how it works. Then I will choose if it matches the spirit or the strategic direction.\n\n**Direct client-to-microservice communication** — front-end developers need to spread tasks for API data integration from multiple services and developing UI/UX. This way is appropriate when the team skill is comprehensive, good in both data manipulation and aesthetic ability.\n\n**API gateway** is centralized management, API gateway has the ability to focus on what it does with a huge of supporting tools, the result is front end developers can focus on developing better UI/UX for end-user without requiring time for the complexity of data integration. This way is appropriate when we have a specialized team.\n\nNext post I will write about using GraphQL to implement the BFF pattern. I choose GraphQL because the concept is very simple: instead of having multiple “dumb” endpoints, have a single “smart” endpoint that can take in complex queries, and then massage the data output into whatever shape the client requires.\n\n## References\n\n[.NET Microservices — Architecture e-book](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/): I use this resource for the concept and the standard term.\n\n[Building Microservices: Using an API Gateway](https://www.nginx.com/blog/building-microservices-using-an-api-gateway/): I follow this series to understand Microservice.\n\n[Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation](https://www.researchgate.net/publication/319187656_Processes_Motivations_and_Issues_for_Migrating_to_Microservices_Architectures_An_Empirical_Investigation): I refer to this paper for the numbers, statistics, of these researchers to avoid opinionated thinking.\n\n[Building a Decoupled Architecture to Optimize our Mobile Apps](https://medium.com/walmartglobaltech/building-a-decoupled-architecture-to-optimize-our-mobile-apps-7bc4a0d6da37): From\nWalmart, I can learn the cost of having a legacy architecture.\n\n[Smart endpoints and dumb pipes design principle](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)\n","slug":"client-to-microservice-communication-strategy-in-a-nutshell"}],"totalCount":3}},"__N_SSG":true}